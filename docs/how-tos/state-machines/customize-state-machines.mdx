# Customizing states machines

State machines modules are included in the corresponding model, so all the strategies described in
the [core customization section](/tutorials/your-first-store/customize-the-core.mdx) are valid.

:::danger

It's better to be conservative when customizing state machines. Try to apply the smallest possible
set of changes, and if possible, avoid changing the defined states. You're dealing with the core of
the domain model: large changes could branch out in unanticipated ways!

:::

## Customizing core behavior

:::danger

Be aware of not overusing transition hooks in the state machines. When the involved logic requires
reaching external services or, more generally, is decoupled from the main flow, you're better
off [leveraging the event bus](#adding-orthogonal-behavior). Otherwise, you will
eventually run into the typical gotchas and downsides of abusing `ActiveRecord` callbacks.

:::

Sometimes you might need to tweak Solidus' core model to fit your business needs. In that case, you
might want to tweak a state machine to obey your extended domain.

Say that you must store the time when a payment has been marked as completed. You already added
a `completed_at` column to the `spree_payments` table, but now you need the payment state machine to
fill it.

You can add an `after_transition hook` using
an [override](/tutorials/your-first-store/customize-the-core.mdx#using-overrides):

```ruby title="app/overrides/my_store/payment_set_completed_at.rb"
# frozen_string_literal: true

module MyStore
  module PaymentSetCompletedAt
    def self.prepended(base)
      base.state_machine.after_transition(to: :completed) do
        self.completed_at = Time.zone.now
      end
    end

    ::Spree::Payment.prepend self
  end
end
```

## Adding orthogonal behavior

:::caution

Don't be confused about state machine events vs. bus events. State machine events are conditions
that can produce a transition between valid states. They're local to the state machine component. On
the other hand, bus events can be published and consumed anywhere within the system and, per se,
have nothing to do with the state machines.

:::

As noted in the [event bus](/reference/event-bus.mdx) guide, you can leverage the
event bus to hook into core events. That's helpful when you need to perform something in response to
a change in the system, but your logic is orthogonal (i.e., decoupled) to the main flow. Transitions
between state machine states are good candidates to become hotspots where tangential logic is
triggered.

For instance, you might want to update your ERP or send an SMS when a payment is marked as
completed. The cleaner way to do that is to publish an event when that happens and then subscribe to
it. First, you need to override the `#complete` event method on `Spree::Payment` (see
the [overrides section](/tutorials/your-first-store/customize-the-core.mdx#using-overrides) for the required
setup code):

```ruby title="app/overrides/my_store/publish_payment_completed.rb"
# frozen_string_literal: true

module MyStore
  module PublishPaymentCompleted
    def complete
      super.tap do |result|
        Spree::Bus.publish(:payment_completed, payment: self) if result
      end
    end

    ::Spree::Payment.prepend self
  end
end
```

Then, after [registering the new event](/reference/event-bus.mdx#custom-events),
you can [create a subscriber](/reference/event-bus.mdx#subscription-to-events) for
it.

:::caution

Why not register a new `after_transition` hook instead of overriding the event method (
i..e, `#complete` in the example above)?

State machine transitions (including their `after_` hooks) are wrapped within a database
transaction. By overriding the method instead of using `after_transition`, we publish the bus event
only after the transaction has been committed to the DB.

Event subscribers should **always** be decoupled from the main transaction, so there's no point in
blocking database access until your subscribers have finished running. In fact, it's a bad practice:
a failed subscriber will roll back the whole DB transaction and potentially leave your system in an
inconsistent state.

:::

:::info

Ideally, Solidus would publish events for every state machine transition out of the box. Our event
bus is fairly new and we're still working on it, but we'll get there eventually! In the meantime,
you can check`Spree::Bus.registered_events` for the complete list of events that are already
published.

:::

## Using custom state machines

If needed, you can flat out replace state machines with your custom implementation. This can be done
through the `state_machines` option in `config/initializers/spree.rb`.

For instance, if you want to replace the payment state machine, you can do it like this:

```ruby title="lib/my_store/state_machines/payment.rb"
# frozen_string_literal: true

module MyStore
  class StateMachines
    module Payment
      extend ActiveSupport::Concern

      included do
        state_machine initial: :custom_state do
          # Event, transition & hook definitions
        end
      end
    end
  end
end
```

And then you need to tell Solidus to use it:

```ruby title="config/initializers/spree.rb"
# ...
Spree.config do |config|
  config.state_machines.payment = 'MyStore::StateMachines::Payment'
  # ...
end
```

:::caution

As always, with great power comes great responsibility. Replacing the whole state machine should be
the outcome of an informed decision. Solidus relies on well-known state machine states and events in
many areas of the core, so be prepared to adjust other parts of Solidus to work with your custom
implementation.

:::
