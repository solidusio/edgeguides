---
sidebar_position: 2
---

# Write the first feature

## Accepting configuration values

A common pattern in extensions is to accept certain configuration values that the user can change in
a Rails initializer. For this reason, the extension skeleton generated by `solidus_dev_support`
ships with a sample configuration file where you can add any options that you want the user to be
able to configure. The skeleton also contains an initializer which will be copied to the main app
when the extension is installed, so that the user doesn't have to write the configuration code
manually.

In the case of our Acme Fulfillment extension, we want to let the user configure their API key. In
order to do this, let's edit the `lib/solidus_acme_fulfillment/configuration.rb` file as follows:

```diff title="lib/solidus_acme_fulfillment/configuration.rb"
 module SolidusAcmeFulfillment
   class Configuration
-    # Define here the settings for this extension, e.g.:
-    #
-    # attr_accessor :my_setting
+    attr_accessor :api_key
   end

   # ...
 end
```

We will also edit the sample initializer to let the user know about the new configuration option:

```diff title="lib/generators/solidus_acme_fulfillment/install/templates/initializer.rb"
 SolidusAcmeFulfillment.configure do |config|
-  # TODO: Remember to change this with the actual preferences you have implemented!
-  # config.sample_preference = 'sample_value'
+  # Set your Acme Fulfillment API key here.
+  config.api_key = 'my-api-key'
 end
```

When a user installs our extension, an initializer will be added to their main application
under `config/initializers/solidus_acme_fulfillment.rb` which will contain our sample configuration.

## Adding new functionality

Customizing Solidus through an extension is very similar to customizing it in the main application,
and the same rules and patterns apply: you can use extension hooks, the event bus, overrides, etc.

:::caution

One important aspect to keep in mind when working on extensions is that you can't predict what other
extensions the user will install, so you need to make sure your customizations play nice with other
extensions.

For example, setting a configuration value in the Solidus configuration is usually discouraged in
extensions, since other extensions may do the same and end up overriding your setting. Instead, you
can change the value by altering the configuration in the main app through your installation
initializer, or document that the value needs to be set in your readme, and let the user do it.

:::

When we described our requirements, we mentioned we want to save the shipment ID that we get back
from the 3PL's API when we create the order, so that we can easily access the shipment later. The
best place to store this information would be an additional column in the `spree_orders` table, so
let's first write a migration to create it:

```bash
$ bin/rails g migration AddAcmeFulfillmentShipmentIdToSpreeOrders \
    acme_fulfillment_shipment_id
```

:::info

You may have noticed that we're not running `rails db:migrate` after generating the migration. This
is because we're working in a Rails engine, not a Rails application. We don't have a database to
work on.

All database migrations that you generate in your extension will be automatically imported into the
main application when the extension is installed via its initializer.

:::

Next, we need to implement the actual code to integrate with the fulfillment partner's API. An event
subscriber seems like the best way to do this, so let's write one:

```ruby title="app/subscribers/solidus_acme_fulfillment/order_subscriber.rb"
module SolidusAcmeFulfillment
  class OrderSubscriber
    include Omnes::Subscriber

    handle :order_finalized, with: :send_to_3pl

    def send_to_3pl(event)
      order = event.payload.fetch(:order)

      response = HTTParty.post(
        'https://api.acmefulfillment.com/orders',
        headers: {
          'Authorization' => "Bearer #{SolidusAcmeFulfillment.config.api_key}",
          'Content-Type' => 'application/json',
          'Accept' => 'application/json',
        },
        body: serialize_order(order).to_json,
      )

      order.update!(
        acme_fulfillment_shipment_id: response.parsed_response['id'],
      )
    end

    private

    def serialize_order(order)
      {
        # ...
      }
    end
  end
end
```

Our event subscriber is pretty simple: it listens to the `:order_finalized`event and, when it's
published, it calls the Acme Fulfillment API with the configured API key and the serialized order
information. It then parses the API response and sets the `acme_fulfillment_shipment_id` column on
the order to the ID returned by the fulfillment partner's API.

:::caution

In the real world, you'd want to move this block of code to a background job, so that it doesn't
unnecessarily slow down your user's HTTP requests with API calls to your fulfillment partner. &#x20;

:::

We still need to subscribe it to the Solidus event bus system. We can do it in our extension's
engine file:

```diff title="lib/solidus_acme_fullfilment/engine.rb"
module SolidusAcmeFulfillment
  class Engine < Rails::Engine
    # ...
+
+    config.to_prepare do
+      SolidusAcmeFulfillment::OrderSubscriber.new.subscribe_to(Spree::Bus)
+    end
   end
 end
```

That's all we needed! The requirements have been satisfied, and it's now time to preview our work.
In order to do that, we'll use the **sandbox app.**
